{% extends "base.html" %}
{% block graph %}


<script src={{ url_for('static', filename='./js/sigma.min.js') }}></script>
<script src={{ url_for('static', filename='./plugins/sigma.plugins.dragNodes.min.js') }}></script>
<script src={{ url_for('static', filename='./plugins/sigma.plugins.filter.min.js') }}></script>
<script src={{ url_for('static', filename='./plugins/sigma.plugins.neighborhoods.min.js') }}></script>
<script src={{ url_for('static', filename='./plugins/sigma.renderers.customShapes.min.js') }}></script>
<script src={{ url_for('static', filename='./plugins/sigma.parsers.gexf.min.js') }}></script>

<div class="container">

<div class="row" style="height:20vh;margin-top:0vh;">
               <div class="col-md-4 col-md-offset-4" style="margin-top:2vh;">
                       <form name = "graphquery" method="GET">
                               <div class="form-group text-center">

                                       <label style="font-weight:300; font-size:36px;">Select Year</label>
                                       <br /><br />
                                       <select class="form-control" name="year">
                                               <option>2015</option>
                                               <option>2014</option>
                                               <option>2013</option>
                                               <option>2012</option>
                                               <option>2011</option>
                                               <option>2010</option>
                                               <option>2009</option>
                                       </select>
                                       <br /><br />
                                       <button type="submit" value="Send" name="graphyear-container" class="btn btn-default id-submit">Submit</button>
                               </div>
                       </form>
               </div>
       </div>

        <div class="row" style="height:100vh;margin-top:15vh;">

<div id="graph-container" style="min-width: 310px; height: 600px; margin: 0 auto">

</div>
</div>
</div>


  
<script>

var filter;

/**
 * DOM utility functions
 */
var _ = {
  $: function (id) {
    return document.getElementById(id);
  },

  all: function (selectors) {
    return document.querySelectorAll(selectors);
  },

  removeClass: function(selectors, cssClass) {
    var nodes = document.querySelectorAll(selectors);
    var l = nodes.length;
    for ( i = 0 ; i < l; i++ ) {
      var el = nodes[i];
      // Bootstrap compatibility
      el.className = el.className.replace(cssClass, '');
    }
  },

  addClass: function (selectors, cssClass) {
    var nodes = document.querySelectorAll(selectors);
    var l = nodes.length;
    for ( i = 0 ; i < l; i++ ) {
      var el = nodes[i];
      // Bootstrap compatibility
      if (-1 == el.className.indexOf(cssClass)) {
        el.className += ' ' + cssClass;
      }
    }
  },

  show: function (selectors) {
    this.removeClass(selectors, 'hidden');
  },

  hide: function (selectors) {
    this.addClass(selectors, 'hidden');
  },

  toggle: function (selectors, cssClass) {
    var cssClass = cssClass || "hidden";
    var nodes = document.querySelectorAll(selectors);
    var l = nodes.length;
    for ( i = 0 ; i < l; i++ ) {
      var el = nodes[i];
      //el.style.display = (el.style.display != 'none' ? 'none' : '' );
      // Bootstrap compatibility
      if (-1 !== el.className.indexOf(cssClass)) {
        el.className = el.className.replace(cssClass, '');
      } else {
        el.className += ' ' + cssClass;
      }
    }
  }
};


function updatePane (graph, filter) {
  // get max degree
  var maxDegree = 0,
      categories = {};
  
  // read nodes
  graph.nodes().forEach(function(n) {
    maxDegree = Math.max(maxDegree, graph.degree(n.id));
    categories[n.attributes.acategory] = true;
  })

  // min degree
  _.$('min-degree').max = maxDegree;
  _.$('max-degree-value').textContent = maxDegree;
  
  // node category
  var nodecategoryElt = _.$('node-category');
  Object.keys(categories).forEach(function(c) {
    var optionElt = document.createElement("option");
    optionElt.text = c;
    nodecategoryElt.add(optionElt);
  });

  // reset button
  _.$('reset-btn').addEventListener("click", function(e) {
    _.$('min-degree').value = 0;
    _.$('min-degree-val').textContent = '0';
    _.$('node-category').selectedIndex = 0;
    filter.undo().apply();
    _.$('dump').textContent = '';
    _.hide('#dump');
  });

  // export button
  _.$('export-btn').addEventListener("click", function(e) {
    var chain = filter.export();
    console.log(chain);
    _.$('dump').textContent = JSON.stringify(chain);
    _.show('#dump');
  });
};





var fn = '{{ fn |safe }}';
//console.log(fn);

sigma.classes.graph.addMethod('neighbors', function(nodeId) {
    var k,
        neighbors = {},
        index = this.allNeighborsIndex[nodeId] || {};

    for (k in index)
      neighbors[k] = this.nodesIndex[k];

    return neighbors;
  });

var sig = new sigma({
            renderer: {
              container: document.getElementById('graph-container'),
              type: 'canvas'
            },
            settings: {
    doubleClickEnabled: false,
    minEdgeSize: 0.5,
    maxEdgeSize: 1.5,
    minNodeSize: 1,
    maxNodeSize: 6,
    labelThreshold: 9,
    enableEdgeHovering: true,
    edgeHoverColor: 'edge',
    defaultEdgeHoverColor: '#000',
    edgeHoverSizeRatio: 1,
    edgeHoverExtremities: true,
    defaultLabelSize: 14
  }
          });


//{{ url_for('static', filename='./data/subreddit.gexf') }}

sigma.parsers.gexf(
  fn,
  sig,
  function(s) {


   s.graph.nodes().forEach(function(n) {
        n.originalColor = n.color;
      });
      s.graph.edges().forEach(function(e) {
        e.originalColor = e.color;
	  e.type = 'curve';
      });
	s.refresh();

   s.bind('clickNode', function(e) {
        var nodeId = e.data.node.id,
            toKeep = s.graph.neighbors(nodeId);
        toKeep[nodeId] = e.data.node;

        s.graph.nodes().forEach(function(n) {
          if (toKeep[n.id])
            n.color = n.originalColor;
          else
            n.color = '#eee';
        });

        s.graph.edges().forEach(function(e) {
          if (toKeep[e.source] && toKeep[e.target])
            e.color = e.originalColor;
          else
            e.color = '#eee';
        });
	s.refresh();
	});

  // When the stage is clicked, we just color each
      // node and edge with its original color.
      s.bind('clickStage', function(e) {
        s.graph.nodes().forEach(function(n) {
          n.color = n.originalColor;
        });

        s.graph.edges().forEach(function(e) {
          e.color = e.originalColor;
        });

        // Same as in the previous event:
        s.refresh();
      }); 

});



</script>

{% endblock %}

